# 12/09/18

-     Leitura do enunciado do trabalho 1 de SISOP:
Notas sobre pontos importantes:

* Biblioteca de threads N:1 (cthread):
criação, execução, sync, término, troca de contextos.

* Funções que usam chamadas de sistema existentes no Linux:
makecontext()
setcontext()
getcontext()
swapcontext()

* Quantidade variável de threads: alocação dinâmica de memória (mconf feelings)

* tid único por thread:
- inteiro positivo de 32 bits (int 4 bytes)
- não será necessário reaproveitar tid

* Eventos que colocam threads no estado apto:
1 - ccreate
2 - cyield
3 - após um csignal para uma thread que estava blocked por cwait
4 - quando uma thread está blocked por cjoin esperando uma thread2, e esta
terminar
5 - preempção por prioridade

* Condições que tiram uma thread de executando:
indo para apto:
1 - cyield
2 - ccreate criando uma thread de maior prioridade
3 - csetprio que diminua sua prioridade para uma prioridade menor do que a de
uma thread que esteja apta
4 - csignal que causa o desbloqueio de uma thread de maior prioridade
indo para bloqueado:
5 - cjoin
6 - cwait
indo para término:
7 - return ou fm da função que executava

* Eventos que colocam uma thread em blocked:
1 - cjoin
2 - cwait (uso de recurso protegido por semáforo)

* Escalonador FIFO PREEMPTIVO POR PRIORIDADE
Três níveis de prioridade: baixo, médio e alto.

* Respeitar rigorosamente a API indicada no enunciado.

* Possuir códigos de erro para primitivas não funcionais ou não implementadas.

* Anotações das funções no próprio cthread.c

* cjoin e csem_init:
quando uma thread t1 vai se bloquear por conta de outra thread t2, tem que
verificar se essa t2 já tem alguém esperando (só uma thread pode se bloquear por
uma dada thread). Se não houver ninguém bloqueado por causa de t2, então é
necessário chamar csem_init. A struct s_sem possui um ponteiro pra fila
(PFILA2), então é basicamente nessa fila que a gente coloca threads que se
bloqueiam por uma dada thread. Provavelmente seria bom criar filas de semáforos:
como podem haver diferentes tipos de recursos sendo controlados por semáforos,
podemos ter por exemplo uma fila de threads que estão bloqueadas por cjoin.
Nessa fila só haverão semáforos com count = 1 (só uma thread pode se bloquear
por uma dada thread). Os membros dessa fila podem ser EDs podem ter um id
(id da thread que está sendo esperada) e um ponteiro pro semáforo que controla
essa thread. Então por ex:
t1 chama cjoin esperando t2
então procura na fila de threads bloqueadas por cjoin se já existe um elemento
com nome t2 (se já existe uma thread bloqueada esperando t2)
se não existe, chama csem_init com count = 1
adiciona esse semáforo pra lista de semáforos pra thread bloqueadas com cjoin
chama cwait pra botar t1 na fila do semáforo pra t2.

* Sobre semáforos:
Quando uma t1 chama cwait ou cjoin e o semáforo ainda não existe, tem que
basicamente inicializar ele com 1 no caso de mutex. Assim, inicializa com 1, e
em seguida a cwait tem que decrementar o valor do semáforo e testar se é menor
ou igual a zero, pra saber se bota pra dormir.
Pra semáforos pra controlar recursos depende, mas sempre chega e decrementa o
valor do semáforo.

* thread main:
A thread main é uma thread criada pelo próprio so quando cria o processo.
A main tbm precisa de um contexto: chamadas getcontext e
makecontext.
O tid da main deve ser 0, e possuir um TCB.
Deve ter a menor prioridade: 0.
